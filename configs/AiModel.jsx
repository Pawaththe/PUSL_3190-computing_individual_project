const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
  
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseModalities: [
    ],
    responseMimeType: "application/json",
  };

    export const GenerateCourseLayout_AI = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate a course tutorial on following details with field as Course name, Description, along with chapter name and duration. Category: 'Technical Interview', Topic: 'JAVA', Level: 'Basic', Duration: '1 Hour', No of Chapters: '5' in JSON format."},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"Course Name\": \"Ace Your Java Technical Interview: Fundamentals\",\n  \"Description\": \"This course provides a comprehensive overview of fundamental Java concepts essential for performing well in technical interviews. It covers basic data types, control flow, object-oriented programming principles, and common data structures, all tailored towards common interview questions and scenarios. This course is designed for candidates with little to no prior experience or those needing a refresher on the basics.\",\n  \"Category\": \"Technical Interview\",\n  \"Topic\": \"JAVA\",\n  \"Level\": \"Basic\",\n  \"Duration\": \"1 Hour\",\n  \"Number of Chapters\": 5,\n  \"Chapters\": [\n    {\n      \"Chapter Name\": \"Introduction to Java and Environment Setup\",\n      \"Duration\": \"10 Minutes\",\n      \"Content\": [\n        \"What is Java and why it's important for interviews?\",\n        \"Brief history of Java.\",\n        \"Setting up the JDK (Java Development Kit).\",\n        \"Choosing an IDE (Integrated Development Environment) - Eclipse, IntelliJ IDEA, VS Code.\",\n        \"Writing and running your first \\\"Hello, World!\\\" program.\",\n        \"Understanding the basic Java program structure (class, main method).\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Data Types, Variables, and Operators\",\n      \"Duration\": \"12 Minutes\",\n      \"Content\": [\n        \"Primitive data types: int, float, double, boolean, char, long, short, byte.\",\n        \"Declaring and initializing variables.\",\n        \"Understanding variable scope.\",\n        \"Operators: Arithmetic, Relational, Logical, Assignment.\",\n        \"Operator precedence.\",\n        \"Type casting (implicit and explicit).\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Control Flow: Conditional Statements and Loops\",\n      \"Duration\": \"15 Minutes\",\n      \"Content\": [\n        \"Conditional Statements: if, else if, else.\",\n        \"Switch statement.\",\n        \"Loops: for, while, do-while.\",\n        \"Nested loops.\",\n        \"Break and continue statements.\",\n        \"Example interview questions related to control flow.\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Object-Oriented Programming (OOP) Fundamentals\",\n      \"Duration\": \"18 Minutes\",\n      \"Content\": [\n        \"Introduction to OOP: Concepts of Classes and Objects.\",\n        \"Defining classes, fields (attributes), and methods (behaviors).\",\n        \"Creating objects from classes.\",\n        \"Constructors: Default and parameterized constructors.\",\n        \"Encapsulation: Hiding data and using access modifiers (public, private, protected).\",\n        \"Brief introduction to Inheritance and Polymorphism (covered in more advanced courses).\",\n        \"`this` keyword usage.\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Introduction to Arrays and Strings\",\n      \"Duration\": \"15 Minutes\",\n      \"Content\": [\n        \"Arrays: Declaring, initializing, and accessing array elements.\",\n        \"One-dimensional and multi-dimensional arrays.\",\n        \"Array length.\",\n        \"Iterating through arrays using loops.\",\n        \"Strings: Creating and manipulating strings.\",\n        \"String methods: length(), charAt(), substring(), equals(), compareTo().\",\n        \"String immutability.\",\n        \"Basic string formatting.\"\n      ]\n    }\n  ]\n}\n```"},
          ],
        },
      ],
    });
  
    // const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // // TODO: Following code needs to be updated for client-side apps.
    // const candidates = result.response.candidates;
    // for(let candidate_index = 0; candidate_index < candidates.length; candidate_index++) {
    //   for(let part_index = 0; part_index < candidates[candidate_index].content.parts.length; part_index++) {
    //     const part = candidates[candidate_index].content.parts[part_index];
    //     if(part.inlineData) {
    //       try {
    //         const filename = `output_${candidate_index}_${part_index}.${mime.extension(part.inlineData.mimeType)}`;
    //         fs.writeFileSync(filename, Buffer.from(part.inlineData.data, 'base64'));
    //         console.log(`Output written to: ${filename}`);
    //       } catch (err) {
    //         console.error(err);
    //       }
    //     }
    //   }
    // }
    // console.log(result.response.text());

    export const GenerateChapterContent_AI = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Explain the concept in detail on Topic:Algorithms and Data Structure with JAVA , Chapter: Introduction to Algorithms and Data Structures, in JSON format with list of array with field as title, explanation on give chapter in detail, Code examples (Code field in <precode> format) if applicable."},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"topic\": \"Algorithms and Data Structures with Java\",\n  \"chapter\": \"Introduction to Algorithms and Data Structures\",\n  \"sections\": [\n    {\n      \"title\": \"What are Algorithms?\",\n      \"explanation\": \"An algorithm is a well-defined sequence of instructions to solve a specific problem. It takes some input, processes it, and produces some output. Key characteristics include: \\n\\n*   **Finiteness:** An algorithm must terminate after a finite number of steps.\\n*   **Definiteness:** Each step must be clearly and unambiguously defined.\\n*   **Input:** An algorithm takes zero or more inputs.\\n*   **Output:** An algorithm produces one or more outputs.\\n*   **Effectiveness:** Each instruction must be basic enough to be carried out in a finite amount of time using pencil and paper.\",\n      \"code_examples\": []\n    },\n    {\n      \"title\": \"What are Data Structures?\",\n      \"explanation\": \"A data structure is a particular way of organizing and storing data in a computer so that it can be used efficiently. Different kinds of data structures are suited to different kinds of applications, and some are highly specialized to specific tasks.  The choice of a data structure can significantly impact the performance of an algorithm.\\n\\nExamples include arrays, linked lists, stacks, queues, trees, graphs, hash tables, etc.\",\n      \"code_examples\": []\n    },\n    {\n      \"title\": \"Why are Algorithms and Data Structures Important?\",\n      \"explanation\": \"Understanding algorithms and data structures is crucial for:\\n\\n*   **Problem Solving:** They provide a framework for breaking down complex problems into manageable steps.\\n*   **Efficient Code:** Choosing the right data structure and algorithm can drastically improve the performance (speed and memory usage) of your programs.\\n*   **Software Engineering:**  They are fundamental concepts in software engineering and are essential for designing and building robust and scalable applications.\\n*   **Career Advancement:** Knowledge of algorithms and data structures is a core requirement for many software development roles and is frequently tested in technical interviews.\",\n      \"code_examples\": []\n    },\n    {\n      \"title\": \"Basic Data Structures in Java\",\n      \"explanation\": \"Here's an introduction to some common data structures in Java, with brief explanations and examples.\\n\\n*   **Arrays:**  A contiguous block of memory used to store a fixed number of elements of the same data type.  Accessed using an index. Offers fast access but fixed size.\",\n      \"code_examples\": [\n        {\n          \"language\": \"java\",\n          \"code\": \"<pre><code>// Array example\\nint[] numbers = new int[5]; // Array of 5 integers\\nnumbers[0] = 10;\\nnumbers[1] = 20;\\nSystem.out.println(numbers[0]); // Output: 10</code></pre>\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Basic Data Structures in Java (Continued)\",\n      \"explanation\": \"*   **Linked Lists:** A sequence of nodes, where each node contains data and a pointer (or link) to the next node in the sequence.  Dynamic size but slower access than arrays.\\n*   **Stacks:** A LIFO (Last-In, First-Out) data structure.  Elements are added and removed from the top of the stack.\\n*   **Queues:** A FIFO (First-In, First-Out) data structure. Elements are added to the rear (enqueue) and removed from the front (dequeue).\\n*   **Sets:** A collection that contains no duplicate elements.  Useful for storing unique values.\\n*   **Maps:** A collection of key-value pairs.  Each key is associated with a value.  Useful for storing and retrieving data based on a unique key.\",\n      \"code_examples\": [\n        {\n          \"language\": \"java\",\n          \"code\": \"<pre><code>// LinkedList example\\nimport java.util.LinkedList;\\n\\npublic class LinkedListExample {\\n    public static void main(String[] args) {\\n        LinkedList<String> names = new LinkedList<>();\\n        names.add(\\\"Alice\\\");\\n        names.add(\\\"Bob\\\");\\n        names.add(\\\"Charlie\\\");\\n        System.out.println(names.get(0)); // Output: Alice\\n    }\\n}\\n\\n// Stack example\\nimport java.util.Stack;\\n\\npublic class StackExample {\\n    public static void main(String[] args) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(10);\\n        stack.push(20);\\n        System.out.println(stack.pop()); // Output: 20\\n    }\\n}\\n\\n// Queue example\\nimport java.util.Queue;\\nimport java.util.LinkedList;\\n\\npublic class QueueExample {\\n    public static void main(String[] args) {\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(\\\"Apple\\\");\\n        queue.offer(\\\"Banana\\\");\\n        System.out.println(queue.poll()); // Output: Apple\\n    }\\n}\\n\\n// Set example\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class SetExample {\\n    public static void main(String[] args) {\\n        Set<String> uniqueNames = new HashSet<>();\\n        uniqueNames.add(\\\"Alice\\\");\\n        uniqueNames.add(\\\"Bob\\\");\\n        uniqueNames.add(\\\"Alice\\\"); // Duplicate - only one \\\"Alice\\\" will be stored\\n        System.out.println(uniqueNames.size()); // Output: 2\\n    }\\n}\\n\\n// Map example\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class MapExample {\\n    public static void main(String[] args) {\\n        Map<String, Integer> ages = new HashMap<>();\\n        ages.put(\\\"Alice\\\", 30);\\n        ages.put(\\\"Bob\\\", 25);\\n        System.out.println(ages.get(\\\"Alice\\\")); // Output: 30\\n    }\\n}\\n</code></pre>\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Basic Algorithms\",\n      \"explanation\": \"Here are a few examples of basic algorithms:\\n\\n*   **Searching Algorithms:** Used to find a specific element within a data structure (e.g., Linear Search, Binary Search).\\n*   **Sorting Algorithms:** Used to arrange elements in a specific order (e.g., Bubble Sort, Insertion Sort, Merge Sort, Quick Sort).\\n*   **Traversal Algorithms:** Used to visit all elements in a data structure (e.g., Tree Traversal, Graph Traversal).\",\n      \"code_examples\": [\n        {\n          \"language\": \"java\",\n          \"code\": \"<pre><code>// Linear Search\\npublic class LinearSearch {\\n    public static int linearSearch(int[] arr, int key) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == key) {\\n                return i; // Key found at index i\\n            }\\n        }\\n        return -1; // Key not found\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] numbers = {5, 2, 9, 1, 5, 6}; \\n        int key = 9;\\n        int index = linearSearch(numbers, key);\\n        if (index != -1) {\\n            System.out.println(\\\"Key \\\" + key + \\\" found at index \\\" + index);\\n        } else {\\n            System.out.println(\\\"Key \\\" + key + \\\" not found\\\");\\n        }\\n    }\\n}\\n\\n// Bubble Sort\\npublic class BubbleSort {\\n    public static void bubbleSort(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j] > arr[j + 1]) {\\n                    // Swap arr[j] and arr[j+1]\\n                    int temp = arr[j];\\n                    arr[j] = arr[j + 1];\\n                    arr[j + 1] = temp;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] numbers = {5, 1, 4, 2, 8}; \\n        bubbleSort(numbers);\\n        System.out.println(\\\"Sorted array:\\\");\\n        for (int num : numbers) {\\n            System.out.print(num + \\\" \\\");\\n        }\\n        System.out.println();\\n    }\\n}\\n</code></pre>\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Algorithm Analysis (Time Complexity)\",\n      \"explanation\": \"Analyzing the efficiency of algorithms is crucial.  **Time complexity** describes how the runtime of an algorithm grows as the input size increases.  We use **Big O notation** to express time complexity.  \\n\\nCommon time complexities include:\\n\\n*   **O(1):** Constant time (e.g., accessing an element in an array by index).\\n*   **O(log n):** Logarithmic time (e.g., Binary Search).\\n*   **O(n):** Linear time (e.g., Linear Search).\\n*   **O(n log n):** Log-linear time (e.g., Merge Sort, Quick Sort - average case).\\n*   **O(n^2):** Quadratic time (e.g., Bubble Sort, Insertion Sort).\\n*   **O(2^n):** Exponential time.\\n*   **O(n!):** Factorial time.\",\n      \"code_examples\": []\n    },\n    {\n       \"title\": \"Algorithm Analysis (Space Complexity)\",\n       \"explanation\": \"Space complexity refers to the amount of memory space required by an algorithm to run to completion. It includes both the space occupied by the input data and any auxiliary space used by the algorithm itself.  Like time complexity, space complexity is often expressed using Big O notation.  Analyzing space complexity helps in optimizing memory usage and preventing memory-related issues.\",\n       \"code_examples\": []\n    },\n    {\n      \"title\": \"Choosing the Right Algorithm and Data Structure\",\n      \"explanation\": \"The best choice of algorithm and data structure depends on:\\n\\n*   **The problem being solved:** Some problems are naturally suited to specific data structures or algorithms.\\n*   **The size of the input data:**  An algorithm that is efficient for small inputs may be inefficient for large inputs.\\n*   **The performance requirements:**  How quickly must the algorithm run? How much memory can it use?\\n*   **The trade-offs between time and space complexity:**  Sometimes, improving the time complexity of an algorithm requires increasing its space complexity, and vice versa.\",\n      \"code_examples\": []\n    },\n    {\n      \"title\": \"Importance of Understanding Big O Notation\",\n      \"explanation\": \"Big O notation is a way to classify algorithms according to how their running time or space requirements grow as the input size grows.  It's a crucial tool for:\\n\\n*   **Comparing Algorithms:**  Big O notation allows you to compare the efficiency of different algorithms and choose the one that is most suitable for your needs.\\n*   **Predicting Performance:**  Big O notation can help you predict how an algorithm will perform as the input size increases.\\n*   **Identifying Bottlenecks:**  Understanding Big O notation can help you identify the parts of your code that are most likely to be bottlenecks and focus your optimization efforts on those areas.\",\n      \"code_examples\": []\n    }\n  ]\n}\n```"},
          ],
        },
      ],
    });